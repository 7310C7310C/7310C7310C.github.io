[{"title":"004. Codewars 之 A Rule of Divisibility by 13 解法","date":"2017-10-11T02:56:32.000Z","path":"2017/10/11/004-Codewars-之-A-Rule-of-Divisibility-by-13-解法/","text":"题目： When you divide the successive powers of 10 by 13 you get the following remainders of the integer divisions: 1, 10, 9, 12, 3, 4. Then the whole pattern repeats. Hence the following method: Multiply the right most digit of the number with the left most number in the sequence shown above, the second right most digit to the second left most digit of the number in the sequence. The cycle goes on and you sum all these products. Repeat this process until the sequence of sums is stationary. ………………………………………………………………… Example: What is the remainder when 1234567 is divided by 13? 7×1 + 6×10 + 5×9 + 4×12 + 3×3 + 2×4 + 1×1 = 178 We repeat the process with 178: 8x1 + 7x10 + 1x9 = 87 and again with 87: 7x1 + 8x10 = 87 ………………………………………………………………… From now on the sequence is stationary and the remainder of 1234567 by 13 is the same as the remainder of 87 by 13: 9 Call thirt the function which processes this sequence of operations on an integer n (&gt;=0). thirt will return the stationary number. thirt(1234567) calculates 178, then 87, then 87 and returns 87. thirt(321) calculates 48, 48 and returns 48 个人解答：123456789remainders = [1, 10, 9, 12, 3, 4]def thirt(n): sum = 0 for i, v in enumerate(reversed(str(n))): sum += int(v) * remainders[i % 6] if sum == n: return sum return thirt(sum) 网友（nhpatt, pompeu2004）最佳实践：1234567array = [1, 10, 9, 12, 3, 4]def thirt(n): total = sum([int(c) * array[i % 6] for i, c in enumerate(reversed(str(n)))]) if n == total: return total return thirt(total)","tags":[{"name":"Codewars","slug":"Codewars","permalink":"http://wiken.top/tags/Codewars/"},{"name":"Python","slug":"Python","permalink":"http://wiken.top/tags/Python/"}]},{"title":"003. Codewars 之 Multiples of 3 and 5 解法","date":"2017-04-13T10:48:25.000Z","path":"2017/04/13/003-Codewars-之-Multiples-of-3-and-5-解法/","text":"题目： If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.Finish the solution so that it returns the sum of all the multiples of 3 or 5 below the number passed in. Note: If the number is a multiple of both 3 and 5, only count it once. 个人解答：123456def solution(number): sum = 0 for i in range(number): if i%3==0 or i%5==0: sum = sum + i return sum 网友（Process 等）最佳实践：12def solution(number): return sum(x for x in range(number) if x % 3 == 0 or x % 5 == 0)","tags":[{"name":"Codewars","slug":"Codewars","permalink":"http://wiken.top/tags/Codewars/"},{"name":"Python","slug":"Python","permalink":"http://wiken.top/tags/Python/"}]},{"title":"002. Codewars 之 Unique In Order 解法","date":"2017-04-13T10:05:47.000Z","path":"2017/04/13/002-Codewars-之-Unique-In-Order-解法/","text":"题目： Implement the function unique_in_order which takes as argument a sequence and returns a list of items without any elements with the same value next to each other and preserving the original order of elements.For example:123unique_in_order('AAAABBBCCDAABBB') == ['A', 'B', 'C', 'D', 'A', 'B']unique_in_order('ABBCcAD') == ['A', 'B', 'C', 'c', 'A', 'D']unique_in_order([1,2,2,3,3]) == [1,2,3] 个人解答：12345678def unique_in_order(iterable): pre_item = None result = [] for item in iterable: if item != pre_item: result.append(item) pre_item = item return result 网友（kmeshu09 等）最佳实践：12345678def unique_in_order(iterable): result = [] prev = None for char in iterable[0:]: if char != prev: result.append(char) prev = char return result","tags":[{"name":"Codewars","slug":"Codewars","permalink":"http://wiken.top/tags/Codewars/"},{"name":"Python","slug":"Python","permalink":"http://wiken.top/tags/Python/"}]},{"title":"001. Codewars 之 Shortest Word 解法","date":"2017-04-13T09:51:00.000Z","path":"2017/04/13/001-Codewars-之-Shortest-Word-解法/","text":"题目： x Simple, given a string of words, return the length of the shortest word(s).String will never be empty and you do not need to account for different data types. 个人解答：1234567def find_short(s): word_list = s.split() len_list = [] for word in word_list: len_list.append(len(word)) l = min(len_list) return l 网友（MiraliN 等）最佳实践：12def find_short(s): return min(len(x) for x in s.split())","tags":[{"name":"Codewars","slug":"Codewars","permalink":"http://wiken.top/tags/Codewars/"},{"name":"Python","slug":"Python","permalink":"http://wiken.top/tags/Python/"}]}]